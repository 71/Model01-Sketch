/**
 * Converts the text found in the README into Kaleidoscope-compatible code.
 *
 * @returns A C++ source code string.
 */
function generateKeymaps(text: string) {
  const customKeys = [] as string[],
        consumerKeys: Record<string, string> = {
          VolUp: "VolumeIncrement",
          VolDown: "VolumeDecrement",
          Prev: "ScanPreviousTrack",
          Next: "ScanNextTrack",
          Play: "PlaySlashPause",
        },
        renamedKeys: Record<string, string> = {
          Left: "Key_LeftArrow",
          Right: "Key_RightArrow",
          Up: "Key_UpArrow",
          Down: "Key_DownArrow",
          LeftParen: "LSHIFT(Key_9)",
          RightParen: "LSHIFT(Key_0)",
          LeftCurly: "Key_LeftCurlyBracket",
          RightCurly: "Key_RightCurlyBracket",
          PrtScreen: "Key_PrintScreen",
          Underscore: "LSHIFT(Key_Minus)",
          Times: "LSHIFT(Key_8)",
          Dollar: "LSHIFT(Key_4)",
          Plus: "LSHIFT(Key_Equals)",
          At: "LSHIFT(Key_2)",
          Question: "LSHIFT(Key_Slash)",
          Hash: "LSHIFT(Key_3)",
          Tilde: "LSHIFT(Key_Backtick)",
          Percent: "LSHIFT(Key_5)",
        };

  function convertKey(key: string) {
    if (key === "-") {
      // Placeholder; no physical key.
      return "";
    }
    if (key === "_") {
      // Do nothing.
      return "XXX";
    }
    if (key === "^") {
      // Copy from above layer.
      return "___";
    }

    let prefix = "",
        suffix = "";

    if (key[0] === "#") {
      key = key.slice(1);

      prefix += "LGUI(";
      suffix += ")";
    }

    let match: RegExpMatchArray | null;

    if (match = /^(\w+)-(\w+)$/.exec(key)) {
      // Custom key.
      let [, key1, key2] = match;

      key1 = renamedKeys[key1] ?? `Key_${key1}`;
      key2 = renamedKeys[key2] ?? `Key_${key2}`;

      const customKey = `${key1}, ${key2}`;
      let index = customKeys.indexOf(customKey);

      if (index === -1) {
        index = customKeys.length;

        customKeys.push(customKey);
      }

      key = `CS(${index})`;
    } else if (match = /^M\((.+?)\)$/.exec(key)) {
      // Macro.
      key = `M(MACRO_${match[1]})`;
    } else if (match = /^ShiftToLayer/.exec(key)) {
      // Nop.
    } else if (key in consumerKeys) {
      // Consumer key.
      key = `Consumer_${consumerKeys[key]}`;
    } else if (key in renamedKeys) {
      // Regular key with shorter name.
      key = `${renamedKeys[key]}`;
    } else {
      // Regular key.
      key = `Key_${key}`;
    }

    return prefix + key + suffix;
  }

  // Parse every row of every layer.
  const rowGroups = text.trim().split("\n\n");

  if (rowGroups.length !== 6) {
    throw `expected 6 groups of rows, got ${rowGroups.length}`;
  }

  const layers: { name: string, keys: string[][] }[] = [
    { name: "PRIMARY", keys: [] },
    { name: "QWERTY" , keys: [] },
    { name: "FN_L"   , keys: [] },
    { name: "FN_R"   , keys: [] },
    { name: "FN_BOTH", keys: [] },
  ];

  for (const rowGroup of rowGroups) {
    const rows = rowGroup.trim().split("\n");

    if (rows.length !== 5) {
      throw `expected 5 rows, got ${rows.length}`;
    }

    for (let i = 0; i < 5; i++) {
      layers[i].keys.push(
        [...rows[i].matchAll(/\S+/g)].map((match) => convertKey(match[0])),
      );
    }
  }

  // Apply transformations to `FN` layers.
  const [primary, qwerty, fnL, fnR, fnBoth] = layers;

  for (const allLayers of [fnL, fnR]) {
    for (let i = 1; i < 4; i++) {
      const layer = allLayers.keys[i],
            start = allLayers === fnL ? 0 : layer.length / 2 | 0,
            end = allLayers === fnL ? layer.length / 2 | 0 : layer.length;

      for (let j = start; j < end; j++) {
        if (layer[j] === "___" && primary.keys[i][j] !== "XXX") {
          layer[j] = `LGUI(${primary.keys[i][j]})`;
        }
      }
    }
  }

  // Format result.
  return `\
    // Automatically generated by ../generateKeymaps.ts. Do not edit.

    KEYMAPS(
      ${layers.map(({ name, keys }) => `[${name}] = KEYMAP\n  (${
        keys.map((keys) => keys.filter((k) => k).join(", ")).join(",\n       ")}),`).join("\n\n  ")}
    );

    inline void setupKeymaps() {
      CS_KEYS(
        ${customKeys.map((k) => `kaleidoscope::plugin::CharShift::KeyPair(${k}),`).join("\n" + " ".repeat(8))}
      );
    }
  `.replace(/^ {4}|^ {2}$/mg, "");
}

// @ts-ignore
const readme = await Deno.readTextFile("./README.md"),
      text = /\n```\n([\s\S]+?)\n```\n/.exec(readme)![1],
      convertedText = generateKeymaps(text);

// @ts-ignore
await Deno.writeTextFile("./Sketch/Keymaps.h", convertedText);
